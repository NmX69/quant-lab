# QUANT LAB PROJECT PLAN - v2.0 (2025-11-20)
# THE DEFINITIVE TRUTH AND ROADMAP — LOCKED

# **0. AI RULES (NON-NEGOTIABLE)**

1. Never redesign or refactor finished phases without explicit instruction.
2. Never add new directories, dependencies, or persistence unless it's architecturally sound.
3. Only work on the current declared phase (right now = **Phase E**).
4. Never move logic out of JSON strategies (SDL evolves only in Phase F, with explicit approval).
5. Always answer user's question or provide any analysis before providing code blocks or files.
6. Output full-file replacements only (or diffs if explicitly asked).
7. Every Python file keeps the exact 4-line header + footer version tag.
8. If unclear → ask; do not guess.
9. Violating any rule above invalidates the entire response.
10. If delivering a zip file, ensure it is VS Code–readable on Windows with proper CRLF, indentation, and no collapsed single-line returns. Deliver only new & changed files.
11. Every py file must have the following header.  If not found there during a file update, it should be created and added/updated.  Upon updating any file and adding APIs, header should be updated to reflect reality.  Every newly created file should have it as well:
# File path
# Purpose:
# API's: 
# Notes: 

EXAMPLE:
# quant_lab.py
# Purpose: Quant-Lab entrypoint (currently launches the backtester GUI).
# APIs: BacktesterGUI
# Notes: Replaced backtester.py as entry point.  Calls BacktesterGUI from gui/backtester_gui.py

12. Every py file must have the following last-line footer.  Every update of a file should increment the verion and update file lines of code:
# file-path version (NNN lines)

EXAMPLE:
# gui/backtester_gui.py v0.3 (619 lines)

---

# **QUANT-LAB & QUANT-LAB-LIVE**

## **Unified Master Project Definition, Architecture, and Engineering Plan**

### *(Hybrid Format — Enterprise clarity + Modular practicality)*

---

# **1. PROJECT OVERVIEW**

Quant-Lab is a full-scale quantitative crypto research platform designed to:

* Import and preprocess historical crypto market data
* Define novel trading strategies using an SDL (Strategy Definition Language)
* Evaluate these strategies under varying market regimes
* Measure performance, robustness, and risk profiles
* Optimize parameter sets and produce stable, deployable strategic templates
* Provide extensive reporting, metrics, logs, GUI visualization, and fitness analysis
* Support fully interactive GUI-driven backtesting and optimization workflows

Quant-Lab-Live (the sister system) extends this framework into the real world:

* Paper trading
* Live trading on MEXC (spot + futures)
* Continuous real-time data consumption
* Real-time regime evaluation
* Strategy routing + risk-controlled execution
* Divergence monitoring (Live vs Paper vs Backtest)
* The “Hellmoon Scanner” for active multi-asset scanning, anomaly detection, and rapid trade opportunity identification
* A unified strategy schema ensuring seamless transition from research → live deployment

Quant-Lab is **research + discovery**.
Quant-Lab-Live is **execution + validation**.

Both share the same conceptual engine, strategy definitions, regime logic, and routing structure.

---

# **2. DESIGN PRINCIPLES**

1. **Single Unified Engine**
   No silos. Backtesting and live trading share the same internal engine modules wherever possible.

2. **SDL-Driven Strategies**
   Strategies expressed as JSON using a declarative definition language.
   No Python editing required to add new strategies.

3. **Regime-Aware Everything**
   Market states control strategy selection, position sizing, risk exposure, and routing.

4. **Modular ≤ 500-line Components**
   Clean, maintainable, AI-editable modules.
   Prefer composition over inheritance.

5. **Backward Compatibility**
   All future schemas (strategy, fitness, config) must remain compatible with the current SDL JSON and saved fitness engine outputs.

6. **Real-World Fidelity**
   Live trading will expose detailed divergences vs. backtests for continuous improvement of slippage models, latency assumptions, and execution risk.

7. **Extensive Logging + Transparency**
   Everything loggable is logged: trades, decisions, regimes, errors, routing, live/paper mismatches.

8. **GUI-First for Usability**
   Core workflows available through Tkinter GUI interfaces with detail windows, fitness dashboards, and reporting.

---

# **3. CURRENT STATE OF CODEBASE**

See project_tree.txt
---

# **4. FUTURE SYSTEM: QUANT-LAB-LIVE**

Quant-Lab-Live extends the architecture without rewriting existing components.

## **4.1 Live Trading Engine**

Must include:

* Real-time price feed (WebSocket + REST fallback)
* Real-time regime inference
* Real-time strategy routing
* Position management
* Trade execution on MEXC spot/futures
* Logging, monitoring, watchdog timers
* Full hot-reload of strategy schemas
* Paper mode, live mode, hybrid mode

Key idea:
**Reuse `engine.py` as much as possible**, swapping out “simulated execution” with “real execution adapters.”

## **4.2 Execution Adapters**

New modules under `core/live/`:

* **mexc_client.py**
  REST & WebSocket wrapper (order book, tick data, order execution)

* **execution_router.py**
  Handles order placement, cancellation, slippage modeling

* **paper_engine.py**
  Runs a live-paper simulation with the same signals but virtual funds

## **4.3 Divergence Tracking**

Quant-Lab-Live logs:

* Expected fill vs actual
* Expected slippage vs actual
* Strategy signal → trade execution latency
* Missed opportunities vs backtest hypothetical

Stored in:

* `core/live/divergence_log.py`

Used to continuously refine:

* Backtest slippage model
* Backtest fill model
* Risk exposure modeling
* Expected vs realized volatility behavior

---

# **5. HELLMOON SCANNER (QUANT-LAB-LIVE MODULE)**

## **5.1 Purpose**

Real-time scanning of **thousands of assets** (spot + futures) to detect:

* Sudden volume spikes
* Orderbook asymmetry
* Implied volatility expansion
* Breakout conditions
* Rapid regime shifts
* Liquidation cascades
* High-confidence directional anomalies

## **5.2 Architecture**

New module:
`core/live/hellmoon_scanner.py`

## **5.3 Pipeline**

1. Subscribe to MEXC tickers list
2. Apply fast, vectorized real-time indicators
3. Measure kurtosis, skew, microstructural imbalance
4. Trigger signals when thresholds are crossed
5. Immediately pass signals → Live Router
6. Live Router checks regime
7. If regime + strategy rules allow, open trade

## **5.4 Routing**

Hellmoon signals flow through the **same strategy schema and risk model** as normal strategies — they’re just “special-case, real-time-only triggers.”

---

# **6. UNIFIED STRATEGY SCHEMA (BACKWARD COMPATIBLE) - COMPLETED**

The future schema must:

* Preserve all current JSON SDL entries
* Add new, optional fields for live trading
* Allow regime-specific additions without breaking old code
* Support Hellmoon event handlers
* Support dynamic risk overrides
* Support live execution preferences

### **6.1 Schema Versioning**

Add a `"schema_version": "1.0"` key.
Older files default to 1.0 if missing.
Future versions remain backward-compatible.

### **6.2 Required New Fields**

```json
"live_settings": {
  "allowed_modes": ["live", "paper"],
  "max_slippage_pct": 0.20,
  "order_type": "market|limit|post-only",
  "cancel_if_latency_ms": 250,
  "hellmoon_compatible": true
}
```

### **6.3 Fitness Export Schema**

The fitness engine must produce a clean JSON output:

```json
{
  "asset": "BTCUSDT",
  "timeframe": "1h",
  "regime": "trending",
  "strategy": "range_mean_reversion",
  "parameters": { ... },
  "risk_model": { ... },
  "expected_performance": { ... },
  "schema_version": "1.0"
}
```

This file loads directly into Quant-Lab-Live.

---

# **7. MODULARITY GOALS (< 500 lines / module)**

All future modules should aim for:

* One clear job
* No multi-hundred-line functions
* No nested logic beyond 3 deep
* 30–50 line function sweet spot
* Clear top-level docstrings + file headers

This maintains long-term AI/human editability.

---

# **8. FUTURE DIRECTORY STRUCTURE (TARGET)**

```text
quant-lab/
    core/
        engine.py
        sizing.py
        indicators.py
        conditions.py
        exits.py
        regime_router.py
        results.py
        ...
        live/
            mexc_client.py
            execution_router.py
            paper_engine.py
            divergence_log.py
            hellmoon_scanner.py
            data_feed.py
    strategies/
        *.json
    gui/
        backtester_gui.py
        live_gui.py
        fitness_detail_window.py
    config/
    data/
    logs/
quant-lab-live/
    (thin wrapper calling /core/live)
```

---

# **9. PHASE ROADMAP (LOCKED)**

**Current active phase: E — Strategy–Regime–Asset Mapping**

### 9.0 Status Summary

* **Phase A — Canonical Trade Logging** → ✅ **COMPLETE**
* **Phase B — Reporting Engine** → ✅ **COMPLETE** (`core/reporting.py` implemented & wired)
* **Phase C — Parameter Optimizer** → ✅ **COMPLETE** (optimizer modules implemented)
* **Phase D — Asset Fitness Tester** → ✅ **COMPLETE** (`asset_fitness` + CLI + GUI integration)
* **Phase E — Strategy–Regime–Asset Mapping** → ✅ **COMPLETE**
* **Phase F — SDL Evolution** → ✅ **COMPLETE**
* **Phase G — Unified Portfolio Engine** → ⏳ Not started
* **Phase H — Real-Time Scanners (incl. Hellmoon)** → ⏳ Not started
* **Phase I — Multi-Timeframe System** → ⏳ Not started
* **Phase J — Dashboard** → ⏳ Not started
* **Phase K — Live Execution Engine (Quant-Lab-Live)** → ⏳ Not started

Phases **E–K** are where the system moves from “backtest lab” to **full-stack quant platform + live / paper execution**, including the Hellmoon module.

---

### 9.1 PHASE A — Canonical Trade Logging (✅ COMPLETE)

**Goal**
Establish a canonical trade log schema + internal plumbing so that all later reporting, optimization, and live comparison share one ground truth.

**What’s already done**

* **A.1 Canonical Trade Schema**

  * Fields implemented: MAE, MFE, pnl_R, reward_multiple, stop_distance_pct, trade_type, hold_time_hours, timestamps, entry/exit prices, size, fee, regime, strategy ID, asset, timeframe.
  * Stored and surfaced via `core.results`, `core.engine`, and GUI detail windows.

* **A.2 Engine & GUI Refactor**

  * Engine split into modular components (engine, sizing, conditions, exits, indicators, `regime_router`, results).
  * GUI (`gui/backtester_gui.py`, `gui/fitness_detail_window.py`) wired to the new reporting / results stack.

**Optional polish (non-blocking, future)**

* Standardize log export schema docs (markdown spec).
* Add explicit version field to TradeLog schema for long-term compatibility.

---

### 9.2 PHASE B — REPORTING ENGINE (✅ COMPLETE, WITH ROOM TO EXTEND)

**Goal**
Produce rich analytics over the canonical trade logs: expectancy, R metrics, volatility, streaks, drawdowns, regime stats, exports.

**What’s already implemented**

* `core/reporting.py` with:

  * Expectancy and win/loss R
  * Basic streak metrics
  * Drawdown-related metrics (via equity curve reconstruction)
  * Regime breakdown logic (per-regime slicing)
  * JSON + CSV export utilities
  * Integration with `core.results` and GUI result views

**Granular tasks & status**

* **B.1 Core Metrics** → ✅
  Expectancy, winrate, avg win R, avg loss R, profit factor, MAR-like ratios.

* **B.2 Volatility & Distribution Metrics** → ✅ basic
  Standard deviation of returns, equity volatility, drawdown stats.

* **B.3 Regime / Strategy / Asset Matrices** → ✅ basic
  Grouped metrics by regime, strategy, asset/timeframe.

* **B.4 Exports (CSV, JSON)** → ✅

  * `export_report_json` / `export_report_csv` implemented.

* **B.5 GUI Surfacing** → ✅ initial

  * Backtester GUI already shows high-level metrics; detail window uses standardized result representations.

**Future refinements (optional, not blocking later phases)**

* Add Sortino and “true MAR” explicitly as labeled metrics.
* Add equity-curve plotting helper (even if GUI doesn’t plot yet, the data is precalculated).

---

### 9.3 PHASE C — PARAMETER OPTIMIZER (✅ COMPLETE)

**Goal**
Explore strategy and risk parameter spaces via grid/EA-style sweeps and summarize fitness.

**What’s already there**

* `core/optimizer.py` facade and `core/optimizer_engine.py`, `core/optimizer_strategy.py`, `core/optimizer_region.py`, `core/optimizer_common.py`.
* Functions for engine-level grid search, strategy parameter sweeps, and region filtering.

**Granular breakdown**

* **C.1 Engine-Level Grid Search** → ✅

  * Sweep risk/position envelopes: R:R, stop widths, ATR multipliers, equity_pct ranges.

* **C.2 Strategy Parameter Search** → ✅

  * Vary EMA lengths, stochastic thresholds, BB params, volatility filters per strategy.

* **C.3 Region Filters & Summaries** → ✅

  * Summarize regions of parameter space with “good” performance.
  * Select stable regions, not just single best points.

* **C.4 Integration with Reporting** → ✅

  * Uses `core.reporting` metrics for fitness values.
  * Feeds into asset fitness.

**Future enhancements (optional)**

* Multi-objective optimization (e.g., maximize expectancy while constraining drawdown).
* Smarter sampling (Latin hypercube, adaptive search) for large parameter spaces.

---

### 9.4 PHASE D — ASSET FITNESS TESTER (✅ COMPLETE)

**Goal**
Produce strategy × asset fitness matrices, regime distributions, and stability rankings.

**What exists now**

* `core/asset_fitness.py` plus `core/fitness_cli.py` and GUI integration via fitness detail window.

**Granular breakdown**

* **D.1 Fitness Matrix Generation** → ✅

  * `run_fitness_matrix` across strategy × asset × timeframe.
  * Uses optimizer + reporting to compute metrics.

* **D.2 Stability Metrics** → ✅

  * `compute_stability_metrics` scores consistency across windows/regimes.

* **D.3 Ranking & Export** → ✅

  * `rank_assets_for_strategy`, `export_fitness_matrix` produce sorted lists and files.

* **D.4 GUI Presentation** → ✅ initial

  * Fitness detail window already visualizes matrices and rankings.

**Key consequence**
We already have **all the ingredients** to select “best-in-class” configurations per asset/regime/timeframe. Phase E formalizes this into a deployable schema.

---

### 9.5 PHASE E — STRATEGY–REGIME–ASSET MAPPING (✅ COMPLETE)


**Goal**
Autogenerate **router-ready schemas** that map:
**(strategy, asset, timeframe, regime, risk model)** → “this is the configuration we should use live/paper.”

This is the bridge from **Quant-Lab** (research) to **Quant-Lab-Live** (deployment).

**Subphases**

* **E.1 Canonical “Best Config” Schema Design**

  * Define a JSON schema (backward compatible) for:

    * asset, timeframe, regime
    * strategy name
    * full parameter set (indicators, thresholds, risk model, fees assumptions)
    * expected performance metrics snapshot
    * meta: created_at, backtest_range, data source, schema_version
  * Must be loadable by both backtester and future live engine.
  * **This JSON file is the exact artifact that Quant-Lab-Live will later import and execute — no translation layer, no config drift.**

* **E.2 Mapping Generator**

  * Implement a function like:
    `generate_mapping_from_fitness(fitness_matrix, selection_rules) -> List[BestConfig]`
  * Selection rules sample:

    * Minimum trades, minimum expectancy, max drawdown, stability thresholds.

* **E.3 Router Integration (Backtest Side)**

  * Allow the current `regime_router` to load these mappings and run a “mapped configuration” backtest:

    * “Run with preselected strategies per asset/regime/timeframe” instead of manually choosing ones.

* **E.4 GUI Integration**

  * In fitness GUI:

    * Button: **“Export Best-Config Schema”**
    * Option to export per asset, per regime, or full matrix.

**Acceptance Criteria**

* Given a completed fitness run, user can click **“Export Mapping”** and get a JSON file that the backtester can re-load and run directly as a “portfolio of best configurations.”
* Files are stable and earmarked for Quant-Lab-Live consumption.

---

### 9.6 PHASE F (✅ COMPLETE)

**Goal**
Extend the Strategy Definition Language without breaking existing strategies or saved configs.

**Subphases**

* **F.1 Schema Versioning & Enforcement**

  * Add `"schema_version"` field; default to `"1.0"` when absent.
  * Create a lightweight validator for SDL JSON:

    * Check required fields, allowed condition/exit types, types of thresholds, etc.

* **F.2 Optional Inheritance**

  * Allow `"extends": "base_strategy_name"` so that strategies can share and override components.
  * Implement a resolver that produces flattened, resolved strategies for engine use.

* **F.3 Multi-Timeframe Support Hooks**

  * Extend SDL to optionally reference signals from higher/lower TFs:

    * E.g., `"confirmations": [{"timeframe": "4h", "condition": "..."}]`
  * Initially wired only on the backtest side; live execution integration comes in Phase I.

* **F.4 New Validated Condition Types**

  * Add clearly defined condition primitives, e.g.:

    * Breakout, volatility band expansions, orderbook-related placeholders (for future live).
  * Keep legacy condition types untouched.

**Acceptance Criteria**

* Old JSON strategies load unmodified.
* New SDL features are optional and validated.
* Strategy loader can describe exactly why a malformed JSON is invalid.

---

### 9.7 PHASE G — UNIFIED PORTFOLIO ENGINE

**Goal**
Run multiple strategies across multiple assets and timeframes under a **global risk & exposure framework**, for both backtest and later live.

**Subphases**

* **G.1 Portfolio State Model**

  * Define an in-memory structure that tracks:

    * Per-asset positions, per-strategy positions, global exposures, margin use, max open risk.

* **G.2 Exposure Constraints**

  * Implement rules like:

    * Max portfolio DD, max per-asset risk, correlation buckets, per-regime caps.
  * Enforce at order-generation time.

* **G.3 Dual Engine Modes**

  * Intraday vs swing “sub-engines” sharing the same portfolio state, but with separate config.

* **G.4 Backtest Integration**

  * Adapt engine/backtest_runner so it can simulate a full portfolio run, not just single-strategy isolated runs.

**Acceptance Criteria**

* Backtests can simulate running N strategies across M assets with shared capital constraints.
* Portfolio metrics (portfolio equity curve, combined drawdown) show up via reporting.

---

### 9.8 PHASE H — REAL-TIME SCANNERS (INCLUDING HELLMOON)

**Goal**
Build real-time anomaly/alpha scanners for live markets; Hellmoon is the flagship module here.

**Subphases**

* **H.1 Live Data Feed Abstraction**

  * Implement a `data_feed` module for streaming tick/candlestick/orderbook snapshots from MEXC.

* **H.2 Generic Scanner Framework**

  * A system to plug in scanner “modules”:

    * Volume spike detector, volatility expansion, orderbook skew, liquidation sweeps.

* **H.3 Hellmoon Scanner**

  * Implement `hellmoon_scanner` that:

    * Monitors thousands of symbols.
    * Evaluates regime + anomaly conditions.
    * Emits **signal events** that can be processed like strategy signals.

* **H.4 Integration With Router & Risk**

  * Hellmoon events go through the same risk / regime / routing layers as traditional signals:

    * No bypassing the portfolio engine or risk caps.

**Acceptance Criteria**

* In live/paper mode, scanner logs detected events + whether trades were taken or rejected.
* Hellmoon can be toggled on/off independently per mode (paper/live).

---

### 9.9 PHASE I — MULTI-TIMEFRAME SYSTEM

**Goal**
Support strategies that combine signals across 1m / 5m / 15m / 1h / 4h / 1d in a principled way.

**Subphases**

* **I.1 Backtest MTF Data Model**

  * Mechanism to align multiple timeframes in memory with consistent indices.

* **I.2 SDL MTF Execution**

  * Activate the multi-timeframe constructs introduced in Phase F:

    * Higher-timeframe trend filters.
    * Lower-timeframe entry triggers.

* **I.3 Live MTF Execution**

  * Manage subscriptions and caches for multiple TFs in the live data feed.
  * Ensure evaluation order and time sync.

**Acceptance Criteria**

* Backtests and live runs can enforce things like:

  * “Trade only when 4h trend is up, 1h RSI in range, and 5m gives entry trigger.”
* All handled through SDL + existing engine, not custom Python logic.

---

### 9.10 PHASE J — DASHBOARD (GUI / TUI / WEB)

**Goal**
Move from “backtester-only GUI” to holistic monitoring, including live and portfolio views.

**Subphases**

* **J.1 Backtester GUI Enhancements**

  * Additional tabs for:

    * Portfolio summary (when G is done)
    * Strategy–asset mappings (Phase E artifacts)

* **J.2 Live Status Dashboard**

  * A new GUI (or eventually web dashboard) that shows:

    * Current positions, unrealized PnL
    * Active regimes, active strategies
    * Scanner/Hellmoon hits
    * Divergence metrics (backtest vs live model assumptions)

* **J.3 CLI/TUI Extension (Optional)**

  * Basic text-based monitoring for headless environments.

**Acceptance Criteria**

* User can run a single interface that shows both backtests and live engines at a high level without digging into logs.

---

### 9.11 PHASE K — LIVE EXECUTION ENGINE (QUANT-LAB-LIVE)

**Goal**
Turn Quant-Lab from pure research into a **live and paper trading engine** on MEXC (spot + futures), while preserving the same logic as backtesting where possible.

This is where **Quant-Lab-Live** formally branches from, but still reuses core modules.

**Subphases**

* **K.1 Exchange Client (MEXC)**

  * REST + WebSocket wrappers for:

    * Market data
    * Order placement, modification, cancellation
    * Account balances, positions, leverage, margin

* **K.2 Execution Adapters**

  * Separate adapters for:

    * **Paper mode**: fill simulation using live data.
    * **Live mode**: real orders, with safety checks and dry-run templates.

* **K.3 Risk & Sanity Layers**

  * Hard kill-switches, max loss per day, per-position caps.
  * Sanity rules: no crazy order types, no cross-leverage surprises.

* **K.4 Divergence Logging**

  * For each trade:

    * Compare expected price/fill vs actual.
    * Log slippage and missed opportunities.
  * Feed this back to improve backtesting models.

* **K.5 Integration With Mapping & Portfolio Engine**

  * Quant-Lab-Live uses the Phase E mapping files + Phase G portfolio engine to decide:

    * Which strategies to run
    * With what parameters
    * Under what exposure constraints.

**Acceptance Criteria**

* System can run **paper trading** using live data end-to-end.
* After hardening, system can run **real trading** with all risk controls engaged.
* Divergence logs clearly highlight model vs reality differences.

---

# **10. FINAL VISION**

Quant-Lab becomes:

* Your **research lab, optimizer, and strategy factory**
* GUI-driven, modular, highly maintainable
* Backed by a sophisticated SDL and regime/fitness system

Quant-Lab-Live becomes:

* Your **execution engine**,
* real-world validator,
* smart-learning trade executor,
* integrated with Hellmoon for continuous alpha discovery.

Both share the same DNA.
Both evolve together.
And both use the same schemas and strategy definitions.


# **11. Known Challenges / Missing Features**

1. **Multi-timeframe backtesting**  
   Still single-timeframe only. Phase I will fix this, but until then higher-TF filters are simulated or manual.

2. **True portfolio-level backtesting**  
   Current runs are still “one asset / one strategy at a time” with isolated equity curves.  
   Phase G (Unified Portfolio Engine) is the blocker for realistic concurrent exposure, correlation, and global risk caps.

3. **Live / paper divergence baseline**  
   No real-world slippage, latency, or fill-rate data yet → backtest assumptions are still optimistic.

4. **SDL schema enforcement & documentation**  
   No formal validator or versioned spec. Phase F will add this, but right now malformed JSON can silently fail or be misinterpreted.

5. **Reward:Risk override persistence bug**  
   When user overrides RR in GUI, the value is used in the run but not yet written back into fitness matrices or exported mappings (shows blank in some tables).

6. **Router mappings are still manual**  
   Phase E is literally the fix for this — right now you have to hand-edit the regime→strategy combos in the GUI.

7. **No production-grade error handling / watchdog in long fitness runs**  
   If a single corrupt CSV or bad asset slips through manifest, the whole matrix can hang or crash without graceful skip + logging.

8. **Hellmoon / scanner logic not even stubbed**  
   Phase H is empty — zero code, zero data feed, zero fast-path.

9. **No web/dashboard or remote monitoring**  
   Everything is local Tkinter only (Phase J).

10. Throught the program strategies are listed like "trend_macd" instead the more friendly in-json name field: "Trending - MACD + ADX" in all windows....

11. When the "Run Backtest" button is pressed, clear the output screen

12. Redo Optimizer windows to be like the tabbed Fitness windows and be full screen

# /project.txt v2.1 (795 lines)