PROJECT.TXT — Quant Lab Master Specification
Version v0.3 (2025–CURRENT)

0. AI USAGE INSTRUCTIONS — STRICT RULESET

Every time you read this file, PRINT THE VERSION LINE ABOVE.
This verifies the AI is using the correct revision.

This section overrides everything else.
It governs ChatGPT, Grok, Claude, Gemini, local models, agent-mode systems, and all future tooling.

Violating any rule in Section 0 invalidates the output.

0.1 Mandatory Operational Rules

Every AI working on Quant Lab must:

0.1.1 Read First

Read the entire project.txt before writing code.

Confirm active phase before making changes.

0.1.2 Follow Active Phase Only

Execute only the current phase.

No jumping ahead.

No scaffolding for future phases.

No “helpful” redesigns unless asked.

0.1.3 File Modification Rules

Only modify files explicitly requested by the user.

Never change unrelated modules.

Never rename files or directories unless ordered.

0.1.4 Preserve Core Architecture

The following principles are immutable:

Unified backtest engine architecture

JSON/SDL-based strategies (no logic in Python)

Regime-aware structure everywhere

Canonical trade logging

Clean separation:

Engine logic

Strategy DSL

Indicators

GUI

Reporting

State

Clear module boundaries (no “bleed” between concerns)

0.1.5 Ask Questions

If anything is ambiguous, the AI must ask for clarification.

0.1.6 Never Assume Missing Files

If a referenced module is not provided, the AI must request it.

0.2 File Output Protocol
0.2.1 Full-File Replacement — PREFERRED

Unless the user explicitly requests a diff, AI must:

Answer questions first (analysis before code).

Summarize the problem.

Summarize required changes.

Request the current version of each file to be modified.

Output complete replacement files, one per code block:

# FILE: core/engine.py
<entire file>


Only modify the files requested.

0.2.2 Diff Workflow — OPTIONAL

Use diffs only when the user requests them.
If using diffs:

AI must test-apply the diff internally before output.

If diff fails when user applies it, AI must analyze why.

0.2.3 Required File Footer Version Tag

Every Python file ends with:

# core/engine.py v0.4


Rules:

Must be the final line.

Version increments monotonically.

Path must match the actual file path.

JSON files cannot have comments.

0.2.4 Required File Header Format (Per-File)

Every Python file in the Quant Lab project must begin with a 3–4 line
header using this exact convention:

# core/engine.py
# Purpose: <one clear sentence describing what this file does>
# Major APIs: <comma-separated list of externally used functions/classes/objects>
# Notes: <optional extra info, may be blank>

Rules:

- The first line must match the logical repo path (e.g., core/sizing.py).
- Purpose must be a single clear sentence describing the module’s responsibility.
- Major APIs must include only the public interface intended to be imported or used by other modules.
- Notes is optional and may include constraints, future concerns, or AI guidance.
- No executable code may appear before the header.
- Header must be updated whenever a refactor changes the purpose or API surface.

For Example:
# core/engine.py
# Purpose: High-level orchestrator for running backtests; delegates real logic to submodules.
# Major APIs: run_backtest
# Notes: Must remain thin; heavy logic lives in sizing/conditions/exits/state.


0.3 Phase Lockout Protocol

Only the active phase may be worked on.

Closed phases cannot be modified.

Future phases cannot be implemented early.

A phase is complete only when the user declares it complete.

0.4 Strategy / SDL Governance

Strategies are JSON-only plug-ins.

AI must:

Preserve schema.

Never alter JSON structure without explicit approval.

Never add new fields/operators/conditions without approval.

Never move logic from JSON into Python.

SDL Evolution Procedure

To modify the DSL:

AI proposes change in English.

User approves.

AI updates project.txt with a new SDL spec section.

Only then can Python/JSON changes be made.

0.5 Architectural Safety

Before writing code, AI must ensure:

No cross-module side effects

No silent global changes

No addition of external dependencies

No changes to directory layout

No performance regressions

No removal of canonical logging fields

0.6 AI Workstyle Requirements

AI must:

Be concise, analytical, and incremental.

Avoid scope creep.

Keep explanations and code separated.

Never output code before analysis.

Justify why each change is appropriate for the current phase.

0.7 When AI Must Decline

AI must refuse code when:

Missing context or missing files

User asks for work from a locked or future phase

Task violates architectural rules

Request is ambiguous

AI should explain the reason and request clarification.

0.8 Enforcement Clause

Any output violating Section 0 is invalid and must be discarded.

1. PROJECT OVERVIEW

Quant Lab is a unified research and backtesting environment for multi-strategy cryptocurrency systems.

Mission:

Run high-volume backtests across many assets

Evaluate strategies by regime and asset

Provide institutional-quality metrics

Prepare for future portfolio engine and live trading

Core Philosophy:

Research-first

JSON strategy plug-ins

Transparent logging

Regime-aware logic

Strong separation of concerns

Extensible long-term architecture

2. CORE DESIGN PRINCIPLES

Unified Engine: Only one backtesting engine.

Strategy Plug-ins: Strategies defined only in JSON (SDL).

Regime Awareness: Search all conditions through a regime lens.

Portfolio-Level Extensions: Reserved for future phases.

Timeframe Agnostic: Works for 1m → 1w.

Transparent Logs: Every decision captured in TradeLog.

Scalable Architecture: Refactor completed to support future phases without monolithic files.

3. CURRENT CODE ARCHITECTURE (AFTER REFACTOR)

This is the authoritative module map.
Updated to match the project as of 2025-11.

Top-Level
quant_lab.py

Main entrypoint.

Creates Tkinter root and starts BacktesterGUI.

config.json

Persisted GUI + engine settings.

Managed exclusively by core/config_manager.py.

getdata.py

Multi-year OHLCV downloader.

Generates manifest.json.

verify_regime.py

CLI tool for verifying regime detection.

README.md

Project overview.

project.txt

This file — canonical spec.

project_tree.txt

High-level file-purpose map.

Useful for new AI sessions.

core/
core/engine.py

High-level orchestrator for backtests.

Coordinates sizing, conditions, exits, and state.

Calls helper modules; contains no heavy logic.

core/sizing.py

All position-sizing and risk model logic.

Supports equity_pct sizing model.

Computes stop distances and take-profit, per GUI inputs.

core/conditions.py

All indicator-based condition evaluation.

invert_condition() and evaluate_condition().

Supports MACD/EMA/Stoch/RSI/BB/ADX/etc.

core/exits.py

All exit logic:

Take profit

Stop loss

Trailing stop

Signal-based exits

End-of-simulation closing

Builds TradeLog with canonical fields.

core/state.py

Tracks:

Position

Capital

High/low watermarks

Entry metadata

Regime counters

Equity curve

Trailing stop state

core/results_builder.py

Computes:

Winrate

Sharpe

Max DD

Final return

Builds BacktestResult and summary text.

core/backtest_runner.py

Non-GUI orchestration layer for:

Single backtest

All strategies on one asset

All assets for one strategy

Used only by GUI.

core/config_manager.py

Reads/writes config.json.

Provides:

PROJECT_ROOT

DATA_DIR

RESULTS_DIR

MANIFEST_FILE

core/indicators.py

Adds indicators (MACD, EMAs, RSI, Stoch, BB, ADX).

Adds regime classification.

Must be called before backtesting.

core/strategy_loader.py

Loads JSON strategy files.

list_strategies(), get_strategy().

core/regime_router.py

Returns correct strategy JSON based on regime.

core/results.py

Data models:

TradeLog

BacktestResult

Handles CSV save and summary_str().

gui/
gui/backtester_gui.py

Main GUI class.

Manages:

File/timeframe/strategy selection

Router controls

Mode selection

Position/risk/RR sliders

Run buttons

Output text

Matplotlib canvas

Calls backtest_runner functions.

gui/layout.py

Builds left and right UI panels.

Extracted to reduce backtester_gui size.

gui/styles.py

ttk style/theme setup.

Colors, fonts, button/combobox styles.

gui/results_display.py

Equity curve plotting

Summary formatting for tables

strategies/

JSON strategy files defining:

Entry conditions

Exit conditions

Risk parameters

Current working strategies:

trend_macd.json

range_rsi_bb.json

trending_ema_crossover.json

ranging_stochastic.json
(And others as added.)

data/

Raw OHLCV CSV files.

manifest.json describing available assets/timeframes.

results/

Stored trade logs (CSV) for each completed backtest.

4. PHASE ROADMAP (OFFICIAL)
PHASE A — Canonical Trade Logging → 100% COMPLETE

Includes:

All canonical fields (MAE/MFE, pnl_R, reward_multiple, stop_distance_pct, trade_type, hold_time_hours)

Full architecture refactor to modular engine + modular GUI

NEXT ACTIVE PHASE → Phase B

PHASE B — REPORTING ENGINE (NEXT)

Implement core/reporting.py:

Expectancy, win/loss R

Sortino, MAR

Volatility of returns

Streaks

Drawdown curve

Regime breakdowns

Strategy/asset matrices

CSV + JSON exports

Plot suite

PHASE C — PARAMETER OPTIMIZER

Grid/EA search across:

R:R

Stop widths

EMA lengths

Stoch thresholds

Volatility filters

ATR multipliers

PHASE D — ASSET FITNESS TESTER

Produce:

Strategy × asset expectancy matrix

Regime distributions

Stability rankings

PHASE E — STRATEGY–REGIME–ASSET MAPPING

Autogenerate router mappings for live trading.

PHASE F — SDL EVOLUTION

Add:

schema enforcement

optional inheritance

multi-timeframe entries

new validated condition types

PHASE G — UNIFIED PORTFOLIO ENGINE

Parallel intraday/swing engines with global exposure caps.

PHASE H — REAL-TIME SCANNERS

Volume spike, moonshot engine, futures OI, flash reversals.

PHASE I — MULTI-TIMEFRAME SYSTEM

Combine 1m + 5m + 15m + 1h + 4h + 1d signals.

PHASE J — DASHBOARD

CLI TUI → Web dashboard.

PHASE K — LIVE EXECUTION ENGINE

Spot/futures execution, slippage model, position router.

5. STRATEGY LIST — CURRENT & PLANNED
Current

Trend-MACD

Range RSI/BB

EMA crossover

Stochastic ranging

Router modes

Planned

Volume spike

Flash crash reversal

Moonshot breakout

Weekly trend

Futures composite

ATR multi-exit

Harmonic multi-entry

6. KNOWN CHALLENGES

Multi-timeframe not implemented

Reporting incomplete

Scanners pending

SDL schema incomplete

Optimizer missing

Portfolio engine missing

Live trading pending

7. CURRENT PHASE

Phase A: COMPLETE
Phase B: NEXT (Reporting Engine)